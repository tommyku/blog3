<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0" name="viewport" /><meta content="Communication between C++ and PHP program using socket - Tommy Ku&#39;s Method Stub - Random thoughts, stories and tutorials of a web dev" name="title" /><meta content="Web developer Tommy Ku talks about his experience in work, learning and life." name="description" /><meta content="Tommy Ku" name="author" /><meta content="Communication between C++ and PHP program using socket - Tommy Ku&#39;s Method Stub - Random thoughts, stories and tutorials of a web dev" property="og:title" /><meta content="article" property="og:type" /><link href="/atom.xml" rel="alternate" title="Tommy Ku&#39;s Method Stub" type="application/atom+xml" /><title>Communication between C++ and PHP program using socket - Tommy Ku&#39;s Method Stub</title><link href="/style/gutenberg.css" rel="stylesheet" /><link href="/style/tomorrow-night-eighties.css" rel="stylesheet" /><meta content="Nanoc 4.8.0" name="generator" /></head><body><header><h2><img alt="Profile pic of Tommy Ku" class="author" src="/assets/images/author.jpg" />Tommy Ku's Method Stub</h2><p><i>Reading and thinking</i></p></header><nav><a href="/">Index</a><a href="https://tommyku.com">About Me</a><a href="https://angel.co/tommyku">AngelList</a><a href="https://www.linkedin.com/in/tommy-chun-kit-ku-65aba999">LinkedIn</a><a href="https://github.com/tommyku">GitHub</a><a href="/atom.xml">Atom Feed</a></nav><main id="main"><section id="meta"><h1>Communication between C++ and PHP program using socket</h1><i>Posted on January 13, 2018</i></section><section id="content">
<h2 id="background">Background</h2>

<p>In a recent job, I had to integrate a piece of hardware with my
PHP server. The only library available was written in C and Java, yet
it’s unreasonable to port the whole PHP application just because it
lacks the library to communicate with the hardware.</p>

<p>Then I came up with an idea of writting a C++ application to bridge the
hardware and the PHP application. The C++ application can use the
library, no problem, but how could I let my C++ and my PHP applications
communicate?</p>

<p>I chose to use socket because it’s straightforward to implement and
reliable enough (for TCP) for my little application that exchanges only
short texts per transaction.</p>

<p>In this short post, I will go over writing a C++ server and a PHP
client that communicate using socket. Demo code can be found on
<a href="https://github.com/tommyku/cpp-php-socket-demo">tommyku/cpp-php-socket-demo</a>.</p>

<h2 id="c-server">C++ Server</h2>

<p>Our C++ server is a simple echo server — it echos back to the
client whatever it receives.</p>

<p>First, we need to include some libraries.</p>

<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

using namespace std;
</code></pre>

<p>Next I create a signal handler to handle <code>SIGTERM</code>, <code>SIGKILL</code> and <code>SIGINT</code>.
This handler becomes useful when I ran my server as a daemon in the background
because I can clean things up such as removing wthe socket file and flushing the log buffer
here when the application closes. Note I made the socket file descriptor <code>server</code>
global so that the signal handler can access it outside of the <code>main</code> function.</p>

<pre><code class="language-cpp">#define SOCKET_FILENAME "/tmp/server.sock"

int server;

void signal_callback_handler(int signum)
{
  // close server
  close(server);
  // remove the socket file
  unlink(SOCKET_FILENAME);
  // signal handled
  exit(0);
}
</code></pre>

<p>Here goes the rest of the application.</p>

<pre><code class="language-cpp">int main(int argc, char **argv)
{
  struct sockaddr_un server_addr, client_addr;
  socklen_t clientlen = sizeof(client_addr);
  int client, buflen, nread;
  char *buf;

  puts("Hell World");

  // listen to SIGINT, SIGTERM, and SIGKILL
  signal(SIGINT, signal_callback_handler);
  signal(SIGTERM, signal_callback_handler);
  signal(SIGKILL, signal_callback_handler);

  // setup socket address structure
  memset(&amp;server_addr, 0, sizeof(server_addr));
  server_addr.sun_family = AF_UNIX;
  strcpy(server_addr.sun_path, SOCKET_FILENAME);

  // create socket
  server = socket(PF_UNIX, SOCK_STREAM, 0);
  if (!server) {
    perror("socket");
    exit(-1);
  }

  // call bind to associate the socket with our local address and
  // port
  if (bind(server, (const struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
    perror("bind");
    exit(-1);
  }

  // convert the socket to listen for incoming connections
  if (listen(server, 0) &lt; 0) {
    perror("listen");
    exit(-1);
  }

  puts("Listening to connection...");

  // allocate buffer
  buflen = 1024;
  buf = new char[buflen+1];

  // loop to handle all requests
  while (1) {
    unsigned int client = accept(server, (struct sockaddr *)&amp;client_addr, &amp;clientlen);

    // read a request
    memset(buf, 0, buflen);
    nread = recv(client, buf, buflen, 0);

    printf("\nClient says: %s\n\n", buf);

    // echo back to the client
    send(client, buf, nread, 0);

    close(client);
  }

  close(server);

  unlink(SOCKET_FILENAME);

return 0;
}
</code></pre>

<p>At first you create a socket file descriptor with socket domain and type,
which hasn’t been bind to anything yet. Then you bind it to a specific address described in
<code>server_addr</code>. After that, you put the socket in passive mode which
waits for clients to approach and make connection.</p>

<p>When creating a socket, I had to made a design decision whether to use
UNIX domain or Internet domain when creating my socket.</p>

<p>UNIX domain (using PF_UNIX when creating socket) is a component of
POSIX, so it’s internal of the host and does not require (de)encapsulation
of the internet and network layer of TCP/IP. Therefore, it’s more
efficient for IPC and more secure as other devices in the LAN cannot tap
into this socket.</p>

<p>On the other hand, Internet domain is just like UNIX domain but the
socket is binded to an address and a port instead of a socket file as in
UNIX domain. It works like UNIX domain socket but other devices in the LAN
can connect to this socket (depending on your firewall setting).</p>

<p>Since the purpose of this socket is purely for interprocess
communication, there is no need to expose the port to outside devices,
so I chose to create my socket in UNIX domain.</p>

<p>In the infinite while loop, the program accepts connection from a
client, and use <code>recv</code> to read the content sent by the client. After
doing something with the content received (in this program it does
nothing), <code>sent</code> is used to send a reply to the client.</p>

<pre><code class="language-cpp">  while (1) {
    unsigned int client = accept(server, (struct sockaddr *)&amp;client_addr, &amp;clientlen);
    // rest of the code...
</code></pre>

<h2 id="php-client">PHP Client</h2>

<p>The PHP code does pretty much the similar thing. Except that instead of
binding to a socket, it connects to a socket that’s already opened by
the C++ program. It will send a message, wait for the first reply while the
C++ program does it’s thing, and then terminate.</p>

<pre><code class="language-php">&lt;?php
error_reporting(E_ALL);

if(!($sock = socket_create(AF_UNIX, SOCK_STREAM, 0)))
{
    $errorcode = socket_last_error();
    $errormsg = socket_strerror($errorcode);

    die("Couldn't create socket: [$errorcode] $errormsg \n");
}

echo "Socket created";

if(!socket_connect($sock , '/tmp/server.sock'))
{
    $errorcode = socket_last_error();
    $errormsg = socket_strerror($errorcode);
    die("Could not connect: [$errorcode] $errormsg \n");
}

echo "Connection established \n";

$message = $argv[1];

if(!socket_send( $sock , $message , strlen($message) , 0))
{
    $errorcode = socket_last_error();
    $errormsg = socket_strerror($errorcode);

    die("Could not send data: [$errorcode] $errormsg \n");
}

echo "Message send successfully \n";

// Now receive reply from server
if(socket_recv( $sock , $buf , 1024, MSG_WAITALL ) === FALSE)
{
    $errorcode = socket_last_error();
    $errormsg = socket_strerror($errorcode);
    die("Could not receive data: [$errorcode] $errormsg \n");
}

echo "Message received \n";

// print the received message
var_dump($buf);

socket_close($sock);
</code></pre>

<p>One thing to note if you’re like me who develops the PHP application in
a docker container which has a separate file system from the host is
that you need to mount the directory where your socket file resides in
the host into the docker container. Otherwise, you may scratch your head
like I did when <code>socket_connect</code> reports: <code>socket_connect(): unable to connect [2]: No such file or directory</code></p>

<h2 id="accepting-one-connection-at-a-time">Accepting one connection at a time</h2>

<p>As the hardware I was working with prohibits parallelism, only one
request should be handled by it at a time. It was tempting for me to
leave the socket open and push the requests into a queue, but how’d the
C++ program know if one request is still valid without the PHP program
first look at the respond of the last request?</p>

<p>As a result, I simply closed the socket once a connection is established
and something is being sent in. The program handles the requets, send a
response back and then binds to the socket again.</p>

<p>To do so, we define a function <code>bind_listen_socket</code> that wraps all the
code needed to create, bind and listen to a socket. This function will
be called when the program starts and after a request has been
processed. This piece of code was originally in <code>main</code> but now it’s
being moved to a function.</p>

<pre><code class="language-cpp">#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

using namespace std;

#define SOCKET_FILENAME "/tmp/server.sock"

int server;

void bind_listen_socket(int &amp;server, sockaddr_un &amp;server_addr)
{
  // create socket
  server = socket(PF_UNIX, SOCK_STREAM, 0);
  if (!server) {
    perror("socket");
    exit(-1);
  }

  // call bind to associate the socket with our local address and
  // port
  if (bind(server, (const struct sockaddr *)&amp;server_addr, sizeof(server_addr)) &lt; 0) {
    perror("bind");
    exit(-1);
  }

  // convert the socket to listen for incoming connections
  if (listen(server, 0) &lt; 0) {
    perror("listen");
    exit(-1);
  }

  puts("Listening to connection...");

}
</code></pre>

<p>The rest of the program remains similar to the orginal version, however
it calls <code>bind_listen_socket</code> whenever it wants to create, bind and
listen to a socket. Moreover, the socket file descriptor is closed and
the socket file removed once there is a request coming in from a client.</p>

<pre><code class="language-cpp">void signal_callback_handler(int signum)
{
  // close server
  close(server);
  // remove the socket file
  unlink(SOCKET_FILENAME);
  // signal handled
  exit(0);
}

int main(int argc, char **argv)
{
  struct sockaddr_un server_addr, client_addr;
  socklen_t clientlen = sizeof(client_addr);
  int client, buflen, nread;
  char *buf;

  puts("Hell World");

  // listen to SIGINT, SIGTERM, and SIGKILL
  signal(SIGINT, signal_callback_handler);
  signal(SIGTERM, signal_callback_handler);
  signal(SIGKILL, signal_callback_handler);

  // setup socket address structure
  memset(&amp;server_addr, 0, sizeof(server_addr));
  server_addr.sun_family = AF_UNIX;
  strcpy(server_addr.sun_path, SOCKET_FILENAME);

  // bind and listen on the socket file
  bind_listen_socket(server, server_addr);

  // allocate buffer
  buflen = 1024;
  buf = new char[buflen+1];

  // loop to handle all requests
  while (1) {
    unsigned int client = accept(server, (struct sockaddr *)&amp;client_addr, &amp;clientlen);

    // got a request, close the socket
    close(server);
    unlink(SOCKET_FILENAME);

    // read a request
    memset(buf, 0, buflen);
    nread = recv(client, buf, buflen, 0);

    printf("\nClient says: %s\n\n", buf);

    // echo back to the client
    send(client, buf, nread, 0);

    close(client);

    sleep(2);

    // re-bind and listen on the socket
    bind_listen_socket(server, server_addr);
  }

  close(server);

  unlink(SOCKET_FILENAME);

  return 0;
}
</code></pre>

<p>During the execution of the <code>while</code> loop body and that 2 seconds delay I
added to demonstrate that the socket really does not take any new
connection during the execution. This is illustrated below. When trying
to connect to the socket, the client couldn’t open the socket file
during the 2-second period.</p>

<pre><code class="language-bash">/run/app # php client.php Hi
Socket createdConnection established 
Message send successfully 
Message received 
string(2) "Hi"

/run/app # php client.php Hi
Socket created
Warning: socket_connect(): unable to connect [2]: No such file or directory in /run/app/client.php on line 14
Could not connect: [2] No such file or directory 

/run/app # php client.php Hi
Socket createdConnection established 
Message send successfully 
Message received 
string(2) "Hi"
</code></pre>

<h2 id="remarks">Remarks</h2>

<p>During the handling of my job and creation of this post,
I learned that socket in UNIX domain is a very fast and effective way to achieve
interprocess communication using different programming languages</p>

<p>The code used as examples here are available at <a href="https://github.com/tommyku/cpp-php-socket-demo">tommyku/cpp-php-socket-demo</a>.
As I was searching for socket programming with PHP and C++, a tutorial from <a href="http://www.binarytides.com/php-socket-programming-tutorial/">BinaryTides</a>
and <a href="https://github.com/zappala/socket-programming-examples-c">zappala/socket-programming-examples-c</a> have been very useful.</p>
</section></main><script src="/js/highlight.pack.js" type="text/javascript"></script><script>(function() {
  hljs.initHighlightingOnLoad();

}).call(this);
</script><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = "https://blog.tommyku.com/blog/communication-between-cpp-and-php-program-using-socket/";
  this.page.identifier = "communication-between-cpp-and-php-program-using-socket";
};

(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = '//methodstub.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a ,="" href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-47055557-3', 'auto');
ga('send', 'pageview');</script></body></html>